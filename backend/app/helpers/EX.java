package helpers;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutionException;

/**
 * Helper class to work with Java8 CompletableFuture and its Exceptions
 */
public final class EX {

    private EX() {
        super();
    }

    /**
     * Use this method to make sure Application Exceptions are unwrapped in case
     * Java8 CompletionStage wrapped them in an ExecutionException or a
     * RuntimeException
     *
     * @param exception
     * @param <T>
     * @return
     */
    public static <T extends Throwable> Throwable unwrap(T exception) {
        if (exception instanceof ExecutionException) {
            return exception.getCause();
        }
        // we're not using instanceof here, as for some Reason the RiagExceptions are
        // subtypes of CompletionException. However, we only want to unpack the
        // CompletionException in case it is a ''Raw-Exception'' which is usually
        // generated by the JDKs CompletionStage handling.
        if (CompletionException.class.equals(exception.getClass())) {
            return exception.getCause();
        }
        return exception;
    }

    /**
     * One line helper to create a CompletionStage which completes exceptionally.
     * Functionally equivalent to Play's F.Promise.throwing
     *
     * @param throwable
     * @param <A>
     * @return
     */
    public static <A> CompletionStage<A> throwing(Throwable throwable) {
        CompletableFuture<A> future = new CompletableFuture<>();
        future.completeExceptionally(throwable);
        return future;
    }


}